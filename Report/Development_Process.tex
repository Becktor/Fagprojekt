%Discuss how development processed, problems encountered and how some features were cut or added.
\chapter{Development Process}
Development started at DATE. The three week period was from DATE to DATE.

\section{Timeplan}%Cebrail/Jonathan
There are several time planning models in the software world. There is agile, iterative and incremental.
\newline
When we started the `Fagprojekt' we created a waterfall chart containing our plans for every week, it was structured in a waterfall chart. The waterfall chart is a sequential design process. It is designed to get through the project phases and have a product as soon as possible. The phases in our project can be seen in the figure below.
\newline
As we revisited our waterfall model steps over time, our main time plan model can be considered to be iterative. The revisits have mainly been to extend features,debugging or optimizing.
\newline
When the waterfall ends and we still have time we will go back and visit the steps and check for new requirements.
\newline
The waterfall gives a good picture of the big phases, but the pre-planned week schedules are not always much help, as they are not dynamic. We can't reconstruct our waterfall every time we meet a conflict. This is here where the timeboxes are handy, which is used to the most detailed part of the time planning - see next subsection. You can check our waterfall timeplan in the appendices, please see Figure~\ref{fig:Waterfall_chart} for that.
\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{Figures/Waterfall}
\caption{An overview of the waterfall phases.}
\label{fig:Waterfall}
\end{figure}
\newpage

\subsection*{Time Boxing} %Jonathan
We were convinced that using "Time Boxing" would be the way to go. Timeboxing divides The schedule into a number of separate time periods(timeboxes), with each part having its own deliverables, deadline and budget. Breaking bigger tasks into smaller tasks with better manageable time frames. What also is important is that by the end of each timebox we need to have a product that if all else fails we can roll back and release our game from an earlier state. The following table shows the timeboxes we have created during the project.
%Please add the following required packages to your document preamble:
%\usepackage[table,xcdraw]{xcolor}
%If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[h]
\begin{tabular}{llll}
  \rowcolor[HTML]{BBDAFF}
  \textbf{week 8-10}	& \textbf{week 11-13}	& \textbf{week 14-15}	& \textbf{week 16-17}	\\
  Code exercise			& Collision detection	& Level generation		& Graphics				\\
  Class design			& Enemies				& Player				& Level generation		\\
  Game Design			& Input					& 						& Sprites				\\
  \rowcolor[HTML]{BBDAFF} 
  \textbf{week 18}		& \textbf{week 19}		& \textbf{week 20}		& \textbf{week 22}		\\
  Endgame				& Attack				& Animation				& Optimization			\\
  Level generation		& Level generation		& Optimization			& 						\\
  						& Optimization			& Sound					& 						\\
  						& 						& Sprites 				& 						\\
  \rowcolor[HTML]{BBDAFF}
  \textbf{week 23}		& \textbf{week 24}		& \textbf{week 25}		& 						\\
  Attacks				& AI					& Bug Fixes				& 						\\
  Coins					& High score			& Code Polish			& 						\\
  Optimization			& Optimization			& Optimization			& 						\\
\end{tabular}
\caption{The timeplan in timebox format.}
\end{table}

\section{Development Issues} %Cebrail / Jonathan / Carsten
We received the Arduino three weeks after project start, which was a major setback in implementation. We could only design the program structure and time-plans in this time. This skewed our planned agile development. Instead of dynamically designing and implementing additional features, we had to make the most of our time and design for three weeks straight, which was followed by weeks of implementation the designed structure and features. Usually in agile processes, you make sure to have a working product at the end of sprints. This was not compatible with our designed framework, since we had taken a lot more features into consideration than possible in a single sprint. It was one very large sprint, more akin to the waterfall process. We could have incrementally implemented the framework after receiving the Arduino, but it would in the end have been slower and more tedious. We had the designs, all we had to do was implement it. In the end we made up for the loss in implementation time by cutting corners in the process and designing a lot ahead.
\newline
Later on one of the Arduinos burned out. It is not clear what went wrong, but it rarely worked. At this time we only had another Leonardo and the Duemilanove, which slowed us down quite a bit. Only half of us could program each week. A few weeks later we hit the maximum code size on the Duemilanove, and were left with only a single working Arduino. Development became too slow, until one of us purchased a second Leonardo.
\newline
General problems with the Arduinos were common. We have also had some issues when uploading code to the Arduino. The screen would be completely black even though the IDE stated the upload was complete. Usually the fix was uploading an example file from the Arduino library that prints text to the screen, usually {\tt HelloWorld.ino}. In other cases a different USB port would solve it, probably a sign of incorrect driver installation. Resetting the Arduino during uploading would also sometimes snap it out of it. Other problems were related to the SD card in the Gameduino 2, where we could not upload programs while the SD card was inserted. Usually formatting the SD card would work, but often only on a Mac for unknown reasons.
