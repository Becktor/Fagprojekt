%Discuss how development processed, problems encountered and how some features were cut or added.
\chapter{Development Process}
Work schedule during 13 week period.\\
       during 3 week period.
       \section{Timeplan}%Cebrail/Jonathan

       There are several time planning models in the software world. There is agile, iterative and incremental.

       When we started the `Fagprojekt' we created a waterfall chart containing our plans for every week, it was structured in a waterfall chart. The waterfall chart is a sequential design process.
       It is designed to get through the project phases and have a product as soon as
       possible. The phases in our project can be seen in the figure below.

       As we revisited our waterfall model steps over time, our main
       time plan model can be considered to be iterative. The revisits have mainly
       been to extend features,debugging or optimizing.

       When the waterfall ends and we still have time
       we will go back and visit the steps and check for new requirements.
       \\The waterfall gives
       a good picture of the big phases, but the pre-planned week schedules are
       not always much help, as they are not dynamic. We can't reconstruct our waterfall every
       time we meet a conflict. This is here where the timeboxes are handy, which is used
       to the most detailed part of the time planning - see next subsection.
       You can check our waterfall timeplan in the appendices, please
       see Figure~\ref{fig:Waterfall_chart} for that.

       \begin{figure}[h]
       \centering
       \includegraphics[scale=0.6]{Figures/Waterfall}
       \caption{An overview of the waterfall phases.}
       \label{fig:Waterfall}
       \end{figure}

       \newpage
       \subsection{Time Boxing} %Jonathan
       We were conviced that using "Time Boxing" would be the way to go.
       Timeboxing divides The schedule into a number of separate time periods(timeboxes), with each part having its own deliverables, deadline and budget.
       Breaking bigger tasks into smaller tasks with better manageable time frames.
       What also is important is that by the end of each timebox we need to have a product that if all else fails we can roll back and release our game from an earlier state. The following table shows the timeboxes we have created during the project.

       % Please add the following required packages to your document preamble:
       % \usepackage[table,xcdraw]{xcolor}
       % If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}

       \begin{table}[h]
       \begin{tabular}{llll}
       \rowcolor[HTML]{BBDAFF}
{\color[HTML]{000000} \textbf{week 8-10}} & {\color[HTML]{000000} \textbf{week 11-13}} & {\color[HTML]{000000} \textbf{week 14-15}} & {\color[HTML]{000000} \textbf{week 16-17}} \\
    Code exercise                        & Enemies                               & Scene generation (simple)             & Graphics                              \\
    Game design                          & Collision Detection                   & Player                                & Sprites                               \\
    Class Design                         & AI                                    &                                       & Map generation                        \\
    & Input                                 &                                       &                                       \\
    Report                               & Report                                & Report                                & Report                                \\
    &                                       &                                       &                                       \\
    \rowcolor[HTML]{BBDAFF} 
    \textbf{week 18-90}                       & \textbf{week 19}                           & \textbf{week 20}                           & \textbf{week 22-25}                        \\
      Endgame                              & Scene generation                      & Sprites                               & Optimization                          \\
      Map generation                       & Optimization                          & Sound                                 &                                       \\
      & Attack                                & Optimization                          &                                       \\
      &                                       & Animation                             &                                       \\
      Report                               & Report                                & Report                                &                                      
      \end{tabular}
      \caption{The timeboxes are seperated per week}
      \end{table}
      \newpage

\section{Hardware}
During the project we have worked with two Arduino types. Duemilanove and Leonardo clone.
The clone was more powerful and therefore was our main used board. The clone is called
OLIMEXINO-32U4.

\subsection{Specications}%Cebrail

\subsubsection{Arduino}
The specs of the Arduino boards vary very much of each other. The OLIMEXINO is definitely
better.

\begin{table}[h]
\resizebox{16cm}{!} {
    \begin{tabular}{l|l|l|l|l|l|l}
    Board name     & Microcontroller & Operating Voltage & Flash Memory & Clock Speed & Input Power & SRAM   \\ \hline
    OLIMEXINO-32U4 & ATMEGA32U4      & 3.3V / 5V         & 32KB         & 16 MHz      & 7-12VDC     & 2.5 KB \\
    Duemilanove    & ATmega168       & 5V                & 16 KB        & 16 MHz      & 7-12V       & 1 KB   \\
    \end{tabular}
}
    \caption{Specifications of the boards}
\end{table}

\subsubsection{Gameduino2}
The specificatins of the Gameduino2\footnote{http://excamera.com/sphinx/gameduino2/} shield:

%\begin{itemize}
%  \footnotesize
%  \item Video output is 480x272 pixels in 24-bit color.
%  \item OpenGL-style command set.
%  \item Up to 2000 sprites, any size.
%  \item 256 Kbytes of video RAM.
%  \item Smooth sprite rotate and zoom with bilinear filtering.
%  \item Smooth circle and line drawing in hardware - 16x antialiased.
%  \item JPEG loading in hardware.
%  \item Built-in rendering of gradients, text, dials and buttons.
%\end{itemize}

\subsection{Nunchuck}%Cebrail
        Both Arduino and the Gameduino 2 shield gives us opportunities to control the game.
Arduino can communicate with a pc and get data when a key is pressed on the keyboard.
The Gameduino 2 is equipped with a touch screen and a accelerometer. We could have used
one of these to get input, but none of them
gives a natural way to play a 'platformer` on a Gameduino 2. The pc solution
feels not natural as the keyboard and the Gameduino 2 screen usually are not in front of each other. The touch screen is not as responsive as we wanted, and it would also be annoying
as the fingers will get in the way. The accelerometer is just wrong in all way, it is hard
to control, as you always has to 'feel' how to hold the device. The problem with fingers
getting in the way appears also here. The best option was using a external controller - a Wii nunhcuk
.
\begin{figure}[b]
  \centering
  \includegraphics{Figures/NunchuckConnection}
  \caption{Hardware connection of an nunchuk}
  \label{fig:nunchuk_connect}
\end{figure}


We heard about this opportunity before we got the Arduinos in our
hands, we thought it would be fun and ordered the adapters just after signing
to this project. Eventually it turned out to be the best option. It does
not have any annoying factors as mentioned with the other opportunities.
The adapters where needed as the nunchuk has to be connected to the Arduino physically.
\\
None of us had much experience in soldering, but our supervisor was happy to help
us in that matter. We got head sockets soldered underneath the boards, which made it
easy to connect the adapter using pin cables.

It is possible to use both the Gameduino 2 and Wii
nunchuk at the same time, even though they use same slots.
Gameduino 2 uses an ISP interface, while the Wii nunchuk uses an I2C interface.


\subsubsection{I2C}
The I2C is a hardware wire interface, which is used by the Wii nunchuk adapter. This bus
interface allows easy communication between components and only requires two
bus lines. These lines are both bidirectional. These bus lines are called SCL
(Serial Clock Line) and SDA (Serial Data Line).

\subsection{Arduino problems}
Throughout our implementation of the game we have had several issues with our arduinos.

\subsubsection{arduino burnout}	
The first problem we ran into was one of our arduino burned out. It was somewhat fixed it would work one day and wouldnt another. Slowly it gave out and now it works 1 out of a 100 tries. We could not find a fix for it. This slowed us down quite a bit since it limited what we could test when working at home.
\subsubsection{arduino duemilanove.}
We ran out of flash memory on the duemilanove since it only has 16kb, this set us back since we only had 1 arduino to code on. We later got this replaced with another leonardo.
\subsubsection{arduino blackout}
We have also had some issues when uploading code to the arduino. Sometimes the arduino screen is black after uploading. To fix this we had to upload an example file from the arduino library that prints text to the screen.
\subsubsection{SD card faliure}
Whilest working on the project suddenly when uploading the arduino couldnt find the SD card in the gameduino. The card was in and had the right files on it. We tried to format the card on windows, it still didn't work. We had a try on a mac and it did.
On one of our arduinos we had the blackout problem as mentioned above but we could not seem to get it fixed. This appeared to be the same problem that the SD card had gone corrupt and needed a format.


