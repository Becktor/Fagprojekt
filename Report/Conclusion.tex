%Summarize the main results. This section should make sense even if the reader has only read the introduction.
\chapter{Conclusion}
The final product satisfies all of our main goals set in Problem Analysis. We implemented a fully functioning, albeit simple, physics engine. It supports the platforming mechanics very well, making the player movement feel natural and responsive. Instead of static speeds, the player accelerates and slowly gains speed up to a maximum speed. The physics engine also works with the enemies, coins and even the minotaurs' dead bodies.
\newline
The enemy minotaurs exhibit different behaviors: wandering, charging and hunting. They wander in horizontal directions until they detect the player. When detected, they will chase the player until either is killed. His chasing movement is simple, but very effective in the small maps, easily navigating the narrow corridors. His attack consists of a charge which only stops when he collides with a wall. We did not however get to implement multiple enemy types because of memory constraints, even though the framework could support it.
\newline
Level generation is also completely implemented. Memory constraints forced us yet again not to use it to the full extent, but the levels are still very different. Units and coins are completely randomly placed around the map, and each level has a path from start to finish. Each level slowly increases in difficulty and resets every time the player dies.
\newline
Animations, scoring and sounds are all in the game too. The animations smoothly transition from one another. The scoring mechanic was implemented with coins too, with a high score that is saved after the Arduino is turned off. Different sounds are played when the hero jumps, attacks, exits and collects coins.